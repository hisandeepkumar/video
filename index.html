<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8">
<title>Gesture Video Player – SMART + MIRRORED</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<style>
  *{box-sizing:border-box;margin:0;padding:0;font-family:Segoe UI,Arial}
  body{background:linear-gradient(135deg,#1a2a6c,#b21f1f,#fdbb2d);color:#fff;display:flex;flex-direction:column;align-items:center;padding:20px}
  .card{background:rgba(0,0,0,.65);padding:16px;border-radius:12px;max-width:640px;width:100%;margin-bottom:16px}
  .videoBox{position:relative;padding-top:56.25%;background:#000;border-radius:8px;overflow:hidden}
  video{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
  .btn{padding:8px 14px;border-radius:999px;background:#4a00e0;color:#fff;border:none;cursor:pointer;font-weight:700}
  .btn.full{background:#ff416c}
  #webcam{width:1px;height:1px;opacity:0;position:absolute;pointer-events:none}
  canvas{width:100%;max-width:560px;border-radius:8px;background:#000}
  .status,.feedback{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,.06);text-align:center}
  .toggleBtn{font-weight:700;padding:10px 16px;border-radius:8px;margin-top:8px;display:inline-block}
  .fullscreen-overlay{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;z-index:9999;display:none;justify-content:center;align-items:center}
  .fullscreen-overlay video{width:100%;height:100%;object-fit:contain}
  .close-fs{position:absolute;top:20px;right:20px;background:rgba(0,0,0,.6);color:#fff;border:none;border-radius:50%;width:50px;height:50px;font-size:24px;cursor:pointer}
</style>
</head>
<body>

<div class="card">
  <h3 style="text-align:center">Video Player</h3>
  <div class="videoBox"><video id="video" controls crossorigin="anonymous"></video></div>
  <div class="controls">
    <button class="btn" id="playPauseBtn">Play/Pause</button>
    <button class="btn" id="volUp">+Vol</button>
    <button class="btn" id="volDown">-Vol</button>
    <button class="btn" id="fwd">+10s</button>
    <button class="btn" id="back">-10s</button>
    <button class="btn full" id="fsBtn">Fullscreen</button>
  </div>
  <input type="file" id="fileInput" accept="video/*" style="display:none">
  <button class="btn" id="uploadBtn" style="margin-top:8px">Upload Video</button>
  <div class="feedback" id="feedback">Ready</div>
</div>

<div class="card">
  <h3 style="text-align:center">Gesture Camera (Mirrored)</h3>
  <canvas id="canvas"></canvas>
  <div class="status" id="status">GESTURES: <span id="toggleStatus" style="color:#0f0">ON</span></div>
  <div class="toggleBtn" id="manualToggle" style="background:#ff416c;cursor:pointer">Manual Toggle</div>
</div>

<video id="webcam" autoplay playsinline></video>

<div class="fullscreen-overlay" id="fsOverlay">
  <button class="close-fs" id="closeFs">X</button>
  <video id="fsVideo" controls></video>
</div>

<script>
/* ---------- VIDEO UI ---------- */
const video    = document.getElementById('video');
const fsVideo  = document.getElementById('fsVideo');
const fsOverlay= document.getElementById('fsOverlay');
const closeFs  = document.getElementById('closeFs');
const fileIn   = document.getElementById('fileInput');
const upload   = document.getElementById('uploadBtn');
const feedback = document.getElementById('feedback');
const status   = document.getElementById('status');
const toggleStatus = document.getElementById('toggleStatus');
const manualToggle = document.getElementById('manualToggle');
const fsBtn    = document.getElementById('fsBtn');

let currentSrc = "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4";
video.src = currentSrc;
fsVideo.src = currentSrc;

upload.onclick = () => fileIn.click();
fileIn.onchange = e => {
  const f = e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  currentSrc = url;
  video.src = url;
  fsVideo.src = url;
  video.load();
  feedback.textContent = 'Video Uploaded!';
};

document.getElementById('playPauseBtn').onclick = () => { video.paused ? video.play() : video.pause(); upd(); };
document.getElementById('volUp').onclick   = () => changeVol(0.1);
document.getElementById('volDown').onclick = () => changeVol(-0.1);
document.getElementById('fwd').onclick     = () => seek(10);
document.getElementById('back').onclick    = () => seek(-10);

function changeVol(d){ video.volume = Math.max(0,Math.min(1,video.volume+d)); upd(); }
function seek(s){ video.currentTime = Math.max(0,Math.min(video.duration,video.currentTime+s)); upd(); }
function upd(){ feedback.textContent = `Time ${Math.round(video.currentTime)}s | Vol ${Math.round(video.volume*100)}%`; }

fsBtn.onclick = () => enterFullscreen();
closeFs.onclick = () => exitFullscreen();
function enterFullscreen(){
  fsOverlay.style.display = 'flex';
  fsVideo.currentTime = video.currentTime;
  fsVideo.volume = video.volume;
  if (!video.paused) fsVideo.play().catch(()=>{});
}
function exitFullscreen(){
  fsOverlay.style.display = 'none';
  video.currentTime = fsVideo.currentTime;
  video.volume = fsVideo.volume;
  if (!fsVideo.paused) video.play().catch(()=>{});
  fsVideo.pause();
}

/* ---------- GESTURE STATE ---------- */
let GESTURES_ENABLED = true;
function setGestures(state){
  GESTURES_ENABLED = state;
  toggleStatus.textContent = state ? 'ON' : 'OFF';
  toggleStatus.style.color = state ? '#0f0' : '#f00';
  status.textContent = `GESTURES: ${state ? 'ON' : 'OFF'}`;
  feedback.textContent = state ? 'Gestures ENABLED' : 'Gestures DISABLED';
}
manualToggle.onclick = () => setGestures(!GESTURES_ENABLED);

/* ---------- MEDIAPIPE ---------- */
const webcam = document.getElementById('webcam');
const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');
let hands, camera;

const COOLDOWN = 1200; // after action
let lastAct = 0;
function cooldown(){ return Date.now()-lastAct < COOLDOWN; }

const pinch = { Left:{active:false,start:null,last:null}, Right:{active:false,start:null,last:null} };
let tapTs   = { Left:0, Right:0 };
const DOUBLE_TAP = 600;
const HOLD_THRESHOLD = 1000; // 1 second hold

let gestureStartTime = {}; // {gestureKey: timestamp}

function fingerState(lm, hand){
  const tips=[8,12,16,20], pips=[6,10,14,18];
  let ext=0;
  for(let i=0;i<4;i++) if(lm[tips[i]].y < lm[pips[i]].y-0.02) ext++;
  const thumbExt = hand==='Right' ? lm[4].x > lm[3].x+0.02 : lm[4].x < lm[3].x-0.02;
  return {ext, thumbExt};
}
function discrete(lm, hand){
  const s = fingerState(lm,hand);
  if(s.ext===0 && !s.thumbExt) return 'fist';
  if(s.ext===4 && s.thumbExt)  return 'openHand';
  return null;
}
function pinchDist(lm,w,h){
  const dx=(lm[4].x-lm[8].x)*w, dy=(lm[4].y-lm[8].y)*h;
  const dist=Math.hypot(dx,dy);
  const cx=(lm[4].x+lm[8].x)/2*w;
  return {dist,cx};
}
function mirrorHand(hand){ return hand === 'Left' ? 'Right' : 'Left'; }

function onResults(res){
  if(!webcam.videoWidth) return;
  canvas.width  = webcam.videoWidth;
  canvas.height = webcam.videoHeight;
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // MIRROR
  ctx.scale(-1, 1);
  ctx.translate(-canvas.width, 0);
  ctx.drawImage(res.image,0,0,canvas.width,canvas.height);
  ctx.setTransform(1,0,0,1,0,0);

  if(!res.multiHandLandmarks || res.multiHandLandmarks.length===0){
    for(const k of ['Left','Right']) if(pinch[k].active){ pinch[k].active=false; pinch[k].start=null; }
    gestureStartTime = {};
    ctx.restore(); return;
  }

  const mirroredLandmarks = res.multiHandLandmarks.map(lm => 
    lm.map(p => ({ x: 1 - p.x, y: p.y, z: p.z }))
  );

  for(let i=0;i<mirroredLandmarks.length;i++){
    const lm = mirroredLandmarks[i];
    window.drawConnectors(ctx,lm,window.HAND_CONNECTIONS,{color:'#0f0',lineWidth:2});
    window.drawLandmarks(ctx,lm,{color:'#ff0',lineWidth:1});
  }

  const handsInfo = [];
  for(let i=0;i<mirroredLandmarks.length;i++){
    const lm   = mirroredLandmarks[i];
    const origHand = (res.multiHandedness?.[i]?.label) ?? 'Right';
    const mirroredHand = mirrorHand(origHand);
    const disc = discrete(lm, mirroredHand);
    handsInfo.push({hand: mirroredHand, disc, lm});
  }

  const anyPinch = pinch.Left.active || pinch.Right.active;

  // === 1. BOTH FISTS → FULLSCREEN (1 sec hold) ===
  if(handsInfo.length === 2 && !anyPinch && !cooldown()){
    const L = handsInfo.find(h=>h.hand==='Left');
    const R = handsInfo.find(h=>h.hand==='Right');
    if(L && R && L.disc==='fist' && R.disc==='fist'){
      const key = 'both_fists';
      if(!gestureStartTime[key]) gestureStartTime[key] = Date.now();
      if(Date.now() - gestureStartTime[key] >= HOLD_THRESHOLD){
        lastAct = Date.now();
        if(fsOverlay.style.display === 'flex') exitFullscreen();
        else enterFullscreen();
        status.textContent = 'Both Fists (1s) → Fullscreen';
        gestureStartTime = {};
      }
      ctx.restore(); return;
    }
  }

  // === 2. TOGGLE GESTURES (1 sec hold) ===
  if(handsInfo.length === 2 && !anyPinch && !cooldown()){
    const L = handsInfo.find(h=>h.hand==='Left');
    const R = handsInfo.find(h=>h.hand==='Right');
    if(L && R){
      const key = `${L.disc}_${R.disc}`;
      if(!gestureStartTime[key]) gestureStartTime[key] = Date.now();
      if(Date.now() - gestureStartTime[key] >= HOLD_THRESHOLD){
        lastAct = Date.now();
        if(L.disc==='openHand' && R.disc==='fist') setGestures(false);
        if(R.disc==='openHand' && L.disc==='fist') setGestures(true);
        gestureStartTime = {};
      }
      ctx.restore(); return;
    }
  }

  if(!GESTURES_ENABLED){ gestureStartTime = {}; ctx.restore(); return; }

  // === 3. PLAY / PAUSE (1 sec hold) ===
  if(handsInfo.length === 1 && !anyPinch && !cooldown()){
    const h = handsInfo[0];
    if(h.disc==='openHand'){
      const key = `single_${h.hand}_open`;
      if(!gestureStartTime[key]) gestureStartTime[key] = Date.now();
      if(Date.now() - gestureStartTime[key] >= HOLD_THRESHOLD){
        lastAct = Date.now();
        if(h.hand==='Left'){
          video.play().catch(()=>{});
          status.textContent='Left Open (1s) → Play';
          feedback.textContent='Playing';
        } else {
          video.pause();
          status.textContent='Right Open (1s) → Pause';
          feedback.textContent='Paused';
        }
        upd();
        gestureStartTime = {};
      }
      ctx.restore(); return;
    }
  }

  // === 4. PINCH → ONLY IF FINGERS ARE OPEN (not fist) ===
  for(let i=0;i<mirroredLandmarks.length;i++){
    const lm   = mirroredLandmarks[i];
    const origHand = (res.multiHandedness?.[i]?.label) ?? 'Right';
    const hand = mirrorHand(origHand);
    const disc = discrete(lm, hand);

    // BLOCK PINCH IN FIST
    if(disc === 'fist') continue;

    const p    = pinchDist(lm,canvas.width,canvas.height);
    const TH   = 50;
    const st   = pinch[hand];

    if(p.dist < TH){
      if(!st.active){
        st.active = true;
        st.start  = {cx:p.cx, t:Date.now(), time:video.currentTime, vol:video.volume};
        st.last   = {cx:p.cx};
      }else{
        const elapsed = Date.now() - st.start.t;
        if(elapsed > 300){
          const dx = p.cx - st.start.cx;
          if(hand === 'Right'){
            const volDelta = dx * 0.002;
            const newVol = Math.max(0, Math.min(1, st.start.vol + volDelta));
            video.volume = newVol;
            feedback.textContent = `Volume ${Math.round(newVol*100)}%`;
            status.textContent = `Right pinch → volume`;
          } else {
            const seekSec = dx * 0.08;
            const target = Math.max(0, Math.min(video.duration, st.start.time + seekSec));
            video.currentTime = target;
            feedback.textContent = `Seek ${Math.round(target)}s`;
            status.textContent = `Left pinch → seek`;
          }
        }
        st.last = {cx:p.cx};
      }
    }else{
      if(st.active){
        const now = Date.now();
        const dur = now - st.start.t;
        if(dur < 300){
          if(now - tapTs[hand] < DOUBLE_TAP && !cooldown()){
            lastAct = now;
            if(hand==='Left'){ seek(-10); }
            else{ seek(10); }
            tapTs[hand]=0;
          }else tapTs[hand]=now;
        }
        st.active=false; st.start=null; st.last=null;
      }
    }
  }

  // Reset gesture timer if not holding
  const currentGestures = handsInfo.map(h => `${h.hand}_${h.disc}`).join('_');
  if(currentGestures !== Object.keys(gestureStartTime).join('_')){
    gestureStartTime = {};
  }

  ctx.restore();
  upd();
}

/* ---------- INIT ---------- */
async function init(){
  hands = new window.Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
  hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
  hands.onResults(onResults);

  camera = new window.Camera(webcam,{
    onFrame:async()=>{await hands.send({image:webcam});},
    width:640,height:480
  });
  try {
    await camera.start();
    setGestures(true);
    status  .textContent = 'Camera Ready | Hold 1s for gesture';
    feedback.textContent = 'Hold gesture for 1 second';
  } catch(err) {
    console.error(err);
    status.textContent = 'Camera Access Denied';
  }
}
window.addEventListener('load',init);
</script>
</body>
</html>
