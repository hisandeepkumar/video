<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gesture Video Player ‚Äî Fixed</title>
<style>
/* (keep your original styles; trimmed for brevity here) */
*{margin:0;padding:0;box-sizing:border-box;font-family:Segoe UI, Tahoma, Geneva, Verdana, sans-serif}
body{background:linear-gradient(135deg,#1a2a6c,#b21f1f,#fdbb2d);color:#fff;min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:2rem}
.container{max-width:1200px;width:100%;display:flex;flex-direction:column;gap:2rem}
/* ...rest of your styles (kept from original) ... */
.video-container{position:relative;width:100%;padding-top:56.25%;background:#000;border-radius:10px;overflow:hidden;margin-bottom:1rem}
#videoPlayer{position:absolute;top:0;left:0;width:100%;height:100%;outline:none}
.webcam-wrap{width:100%;max-width:500px;border-radius:10px;background:#000;overflow:hidden}
#webcam{display:block;width:100%;height:auto}
.status{padding:1rem;border-radius:10px;text-align:center;font-weight:bold;margin-top:1rem;background:rgba(255,255,255,0.1)}
.status.active{background:rgba(0,255,0,0.12);color:#00ff00}
.status.inactive{background:rgba(255,0,0,0.12);color:#ff4d4d}
/* keep rest of your original styles */
.fullscreen-overlay{position:fixed;top:0;left:0;width:100vw;height:100vh;background:black;z-index:1000;display:none}
.fullscreen-video{width:100%;height:100%;object-fit:contain}
.close-fullscreen{position:absolute;top:20px;right:20px;background:rgba(0,0,0,0.5);color:white;border:none;border-radius:50%;width:40px;height:40px;font-size:1.5rem;cursor:pointer;z-index:1001}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Gesture Video Player</h1>
    <p class="subtitle">Control video playback with hand gestures using OpenCV</p>
  </header>

  <div class="main-content" style="display:flex;gap:2rem;flex-wrap:wrap;justify-content:center">
    <div class="video-section" style="flex:1;min-width:300px;background:rgba(0,0,0,0.7);padding:1.5rem;border-radius:15px">
      <h2>Video Player</h2>
      <div class="video-container">
        <video id="videoPlayer" controls>
          Your browser does not support the video tag.
        </video>
      </div>

      <div class="controls" style="display:flex;gap:1rem;flex-wrap:wrap;margin-top:1rem">
        <button class="btn" id="playPauseBtn">‚ñ∂Ô∏è Play/Pause</button>
        <button class="btn" id="volumeUpBtn">üîä Volume Up</button>
        <button class="btn" id="volumeDownBtn">üîâ Volume Down</button>
        <button class="btn" id="seekForwardBtn">‚è© Forward 10s</button>
        <button class="btn" id="seekBackwardBtn">‚è™ Backward 10s</button>
        <button class="btn btn-fullscreen" id="fullscreenBtn">üì∫ Fullscreen</button>
      </div>

      <div class="upload-section" style="margin-top:1rem">
        <input type="file" id="fileInput" accept="video/*" style="display:none">
        <button class="btn upload-btn" id="uploadBtn">üìÅ Upload Video</button>
        <p>Supported formats: MP4, WebM, OGG</p>
      </div>
    </div>

    <div class="gesture-section" style="flex:1;min-width:300px;background:rgba(0,0,0,0.7);padding:1.5rem;border-radius:15px">
      <h2>Gesture Controls</h2>
      <div class="gesture-container" style="display:flex;flex-direction:column;align-items:center">
        <div class="webcam-wrap">
          <video id="webcam" autoplay playsinline muted></video>
        </div>
        <div class="status inactive" id="gestureStatus">Gesture recognition inactive</div>

        <div class="gesture-info" style="margin-top:1rem;background:rgba(255,255,255,0.06);padding:1rem;border-radius:10px;width:100%">
          <h3>Available Gestures:</h3>
          <div class="gesture-list" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:1rem;margin-top:1rem">
            <div class="gesture-item">‚úã Open Hand: Play/Pause</div>
            <div class="gesture-item">üëç Thumbs Up: Volume Up</div>
            <div class="gesture-item">üëé Thumbs Down: Volume Down</div>
            <div class="gesture-item">üëâ Swipe Right: Forward 10s</div>
            <div class="gesture-item">üëà Swipe Left: Backward 10s</div>
            <div class="gesture-item">ü§ö Fist/Stop: Fullscreen</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer style="margin-top:2rem;text-align:center;opacity:0.8">
    <p>Gesture Video Player &copy; 2023 | Powered by OpenCV.js</p>
  </footer>
</div>

<div class="fullscreen-overlay" id="fullscreenOverlay">
  <button class="close-fullscreen" id="closeFullscreen">‚úï</button>
  <video class="fullscreen-video" id="fullscreenVideo" controls></video>
</div>

<script src="https://docs.opencv.org/4.5.0/opencv.js" type="text/javascript"></script>
<script>
/* ======== DOM elements ======== */
const videoPlayer = document.getElementById('videoPlayer');
const webcam = document.getElementById('webcam');
const fileInput = document.getElementById('fileInput');
const uploadBtn = document.getElementById('uploadBtn');
const playPauseBtn = document.getElementById('playPauseBtn');
const volumeUpBtn = document.getElementById('volumeUpBtn');
const volumeDownBtn = document.getElementById('volumeDownBtn');
const seekForwardBtn = document.getElementById('seekForwardBtn');
const seekBackwardBtn = document.getElementById('seekBackwardBtn');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const fullscreenOverlay = document.getElementById('fullscreenOverlay');
const fullscreenVideo = document.getElementById('fullscreenVideo');
const closeFullscreen = document.getElementById('closeFullscreen');
const gestureStatus = document.getElementById('gestureStatus');

/* ======== video upload handlers ======== */
uploadBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  videoPlayer.src = url;
  fullscreenVideo.src = url;
  videoPlayer.play().catch(()=>{/* autoplay blocked */});
});

/* simple controls */
playPauseBtn.addEventListener('click', ()=> videoPlayer.paused ? videoPlayer.play() : videoPlayer.pause());
volumeUpBtn.addEventListener('click', ()=> videoPlayer.volume = Math.min(1, videoPlayer.volume + 0.1));
volumeDownBtn.addEventListener('click', ()=> videoPlayer.volume = Math.max(0, videoPlayer.volume - 0.1));
seekForwardBtn.addEventListener('click', ()=> videoPlayer.currentTime = Math.min(videoPlayer.duration || Infinity, videoPlayer.currentTime + 10));
seekBackwardBtn.addEventListener('click', ()=> videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 10));
fullscreenBtn.addEventListener('click', () => {
  fullscreenOverlay.style.display = 'block';
  fullscreenVideo.currentTime = videoPlayer.currentTime;
  fullscreenVideo.play().catch(()=>{});
});
closeFullscreen.addEventListener('click', () => {
  fullscreenOverlay.style.display = 'none';
  fullscreenVideo.pause();
});

/* ======== OpenCV & webcam setup ======== */
let stream = null;
let cap = null;
let src = null;
let gray = null;
let dst = null;
let processing = false;
let lastGestureTime = 0;
let prevCentroid = null; // for swipe detection
const GESTURE_DEBOUNCE_MS = 1200;
const SWIPE_THRESHOLD = 40; // px

// start webcam
async function startWebcam() {
  try {
    stream = await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}, audio:false});
    webcam.srcObject = stream;
    // wait until the video has loaded metadata / started
    await new Promise(resolve => {
      webcam.onloadedmetadata = () => {
        webcam.play().catch(()=>{});
        resolve();
      };
    });
    // ensure OpenCV runtime ready
    if (cv && cv.getBuildInformation) {
      initOpenCVObjects();
    } else {
      cv['onRuntimeInitialized'] = () => initOpenCVObjects();
    }
  } catch (err) {
    console.error("Webcam error:", err);
    gestureStatus.textContent = "Webcam access denied";
    gestureStatus.className = "status inactive";
  }
}

// create Mats & VideoCapture after webcam dimensions available
function initOpenCVObjects() {
  const w = webcam.videoWidth || 640;
  const h = webcam.videoHeight || 480;

  // create mats with correct sizes
  src = new cv.Mat(h, w, cv.CV_8UC4);
  gray = new cv.Mat();
  dst = new cv.Mat(h, w, cv.CV_8UC1);

  cap = new cv.VideoCapture(webcam); // IMPORTANT: create cap after video element is playable

  gestureStatus.textContent = "Gesture recognition active";
  gestureStatus.className = "status active";
  processing = true;
  requestAnimationFrame(processLoop);
}

/* process frames: use requestAnimationFrame loop, but throttle to ~10 fps for CPU */
let lastProcessTimestamp = 0;
const PROCESS_INTERVAL_MS = 100; // approx 10 fps

function processLoop(ts) {
  if (!processing) return;

  if (!lastProcessTimestamp || (ts - lastProcessTimestamp) >= PROCESS_INTERVAL_MS) {
    lastProcessTimestamp = ts;
    try {
      // read frame
      cap.read(src);
      // convert to gray and blur
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      // simple threshold to get silhouette (demo purpose)
      cv.threshold(gray, dst, 120, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

      // morphology to reduce noise
      let M = cv.Mat.ones(5,5,cv.CV_8U);
      cv.morphologyEx(dst, dst, cv.MORPH_OPEN, M);
      M.delete();

      // find contours
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      analyzeContours(contours);

      // cleanup
      hierarchy.delete();
      contours.delete();
    } catch (err) {
      console.error("Processing error:", err);
    }
  }

  requestAnimationFrame(processLoop);
}

function analyzeContours(contours) {
  let maxArea = 0;
  let maxIdx = -1;

  for (let i=0; i<contours.size(); i++) {
    let cnt = contours.get(i);
    let area = cv.contourArea(cnt);
    if (area > maxArea) { maxArea = area; maxIdx = i; }
    cnt.delete(); // delete the temporary Mat we got
  }

  // threshold to ignore small noise
  if (maxIdx === -1 || maxArea < 3000) {
    // no valid hand
    prevCentroid = null;
    return;
  }

  // retrieve largest contour
  let largest = contours.get(maxIdx);
  // bounding rect & centroid
  let rect = cv.boundingRect(largest);
  const aspectRatio = rect.width / rect.height;
  const centroid = { x: rect.x + rect.width/2, y: rect.y + rect.height/2 };

  // detect swipes: compare centroid x movement
  if (prevCentroid) {
    const dx = centroid.x - prevCentroid.x;
    if (Math.abs(dx) > SWIPE_THRESHOLD) {
      if (dx > 0) triggerGesture('swipeRight');
      else triggerGesture('swipeLeft');
      prevCentroid = centroid;
      largest.delete();
      return;
    }
  }

  // Very simple heuristics:
  // wide shapes -> open hand, tall shapes -> thumb-ish, square -> fist
  if (aspectRatio > 1.15) {
    triggerGesture('openHand');
  } else if (aspectRatio < 0.8) {
    // we try thumbs up/down based on centroid y relative to frame center
    const frameCenterY = webcam.videoHeight / 2;
    if (centroid.y < frameCenterY) {
      triggerGesture('thumbsUp');
    } else {
      triggerGesture('thumbsDown');
    }
  } else {
    // near-square => fist => fullscreen
    triggerGesture('fist');
  }

  prevCentroid = centroid;
  largest.delete();
}

function triggerGesture(name) {
  const now = Date.now();
  if (now - lastGestureTime < GESTURE_DEBOUNCE_MS) return;
  lastGestureTime = now;

  switch (name) {
    case 'openHand':
      if (videoPlayer.paused) videoPlayer.play(); else videoPlayer.pause();
      showFeedback("Play/Pause");
      break;
    case 'thumbsUp':
      videoPlayer.volume = Math.min(1, videoPlayer.volume + 0.1);
      showFeedback("Volume Up");
      break;
    case 'thumbsDown':
      videoPlayer.volume = Math.max(0, videoPlayer.volume - 0.1);
      showFeedback("Volume Down");
      break;
    case 'fist':
      fullscreenOverlay.style.display = 'block';
      fullscreenVideo.currentTime = videoPlayer.currentTime;
      fullscreenVideo.play().catch(()=>{});
      showFeedback("Fullscreen");
      break;
    case 'swipeRight':
      videoPlayer.currentTime = Math.min(videoPlayer.duration || Infinity, videoPlayer.currentTime + 10);
      showFeedback("Forward 10s");
      break;
    case 'swipeLeft':
      videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 10);
      showFeedback("Backward 10s");
      break;
    default:
      console.log("Unknown gesture:", name);
  }
}

function showFeedback(text) {
  gestureStatus.textContent = `Gesture detected: ${text}`;
  gestureStatus.className = "status active";
  setTimeout(()=> {
    gestureStatus.textContent = "Gesture recognition active";
    gestureStatus.className = "status active";
  }, 1400);
}

/* cleanup on unload */
window.addEventListener('beforeunload', () => {
  processing = false;
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
  }
  try { if (src) src.delete(); } catch {}
  try { if (gray) gray.delete(); } catch {}
  try { if (dst) dst.delete(); } catch {}
  try { if (cap) cap.delete(); } catch {}
});

/* start */
startWebcam();
</script>
</body>
</html>
